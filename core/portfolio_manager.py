"""\nüõ°Ô∏è PORTFOLIO MANAGER - CORRELATION-ADJUSTED POSITION SIZING\n=================================================================\n\nAdvanced portfolio management system that prevents overexposure\nby adjusting position sizes based on inter-position correlation.\n\nAuthor: Juan Carlos Garcia Arriero (juankaspain)\nVersion: 9.0 - PORTFOLIO CORRELATION MANAGEMENT\nDate: 19 January 2026\n\nFEATURES:\n- Position correlation calculation\n- Correlation-adjusted Kelly sizing\n- Portfolio risk metrics\n- Concentration detection\n- Dynamic exposure limits\n"""\n\nimport logging\nimport numpy as np\nfrom typing import Dict, List, Optional, Tuple\nfrom dataclasses import dataclass, field\nfrom datetime import datetime\nfrom enum import Enum\n\n\nclass PositionStatus(Enum):\n    """Position lifecycle status"""\n    OPEN = "open"\n    CLOSED = "closed"\n    PENDING = "pending"\n\n\n@dataclass\nclass Position:\n    """Trading position with metadata"""\n    id: str\n    strategy: str\n    token_id: str\n    direction: str\n    entry_price: float\n    size_usd: float\n    stop_loss: float\n    take_profit: float\n    opened_at: datetime\n    status: PositionStatus = PositionStatus.OPEN\n    market_data: Dict = field(default_factory=dict)\n    correlation_features: Dict = field(default_factory=dict)\n    closed_at: Optional[datetime] = None\n    exit_price: Optional[float] = None\n    pnl: float = 0.0\n    \n    def get_correlation_vector(self) -> np.ndarray:\n        """Get feature vector for correlation calculation"""\n        # Extract key features for correlation\n        features = [\n            self.correlation_features.get('btc_exposure', 0.0),\n            self.correlation_features.get('sentiment', 0.0),\n            self.correlation_features.get('volume_profile', 0.0),\n            self.correlation_features.get('trend_direction', 0.0),\n            self.correlation_features.get('volatility', 0.0),\n            1.0 if self.direction == "YES" else -1.0,  # Direction\n        ]\n        return np.array(features)\n\n\n@dataclass\nclass PortfolioConfig:\n    """Portfolio management configuration"""\n    max_total_exposure: float = 0.60  # 60% of bankroll\n    max_position_pct: float = 0.10    # 10% per position\n    max_correlated_exposure: float = 0.30  # 30% in correlated positions\n    correlation_threshold: float = 0.5     # 50% correlation considered significant\n    max_concentration: float = 0.40        # 40% max in single asset class\n    enable_correlation_adjustment: bool = True\n\n\nclass PortfolioManager:\n    """\n    Advanced portfolio manager with correlation-aware position sizing.\n    \n    Prevents overexposure by:\n    1. Tracking all open positions\n    2. Calculating correlation between positions\n    3. Adjusting new position sizes based on existing correlated exposure\n    4. Monitoring portfolio risk metrics\n    """\n    \n    def __init__(self, \n                 bankroll: float,\n                 config: Optional[PortfolioConfig] = None):\n        self.logger = logging.getLogger(__name__)\n        self.bankroll = bankroll\n        self.config = config or PortfolioConfig()\n        \n        self.positions: Dict[str, Position] = {}\n        self.position_counter = 0\n        \n        self.total_pnl = 0.0\n        self.closed_positions = []\n        \n        self.logger.info(f"‚úÖ PortfolioManager initialized | Bankroll: ${bankroll:,.2f}")\n    \n    # ========================================================================\n    # POSITION MANAGEMENT\n    # ========================================================================\n    \n    def add_position(self, position: Position) -> str:\n        """Add new position to portfolio"""\n        position_id = f"pos_{self.position_counter:04d}"\n        self.position_counter += 1\n        \n        position.id = position_id\n        self.positions[position_id] = position\n        \n        self.logger.info(\n            f"‚ûï Position opened | ID: {position_id} | "\n            f"Strategy: {position.strategy} | "\n            f"Size: ${position.size_usd:.2f}"\n        )\n        \n        return position_id\n    \n    def close_position(self, \n                      position_id: str, \n                      exit_price: float, \n                      outcome: str) -> float:\n        """Close position and calculate P&L"""\n        if position_id not in self.positions:\n            raise ValueError(f"Position {position_id} not found")\n        \n        position = self.positions[position_id]\n        \n        # Calculate P&L\n        if outcome == "win":\n            pnl = position.size_usd * (\n                (exit_price - position.entry_price) / position.entry_price\n            )\n        else:\n            pnl = -position.size_usd * (\n                (position.entry_price - position.stop_loss) / position.entry_price\n            )\n        \n        # Update position\n        position.status = PositionStatus.CLOSED\n        position.exit_price = exit_price\n        position.closed_at = datetime.now()\n        position.pnl = pnl\n        \n        # Update portfolio\n        self.total_pnl += pnl\n        self.bankroll += pnl\n        \n        # Move to closed positions\n        self.closed_positions.append(position)\n        del self.positions[position_id]\n        \n        self.logger.info(\n            f"‚ùå Position closed | ID: {position_id} | "\n            f"Outcome: {outcome} | P&L: ${pnl:+,.2f} | "\n            f"New Bankroll: ${self.bankroll:,.2f}"\n        )\n        \n        return pnl\n    \n    def get_open_positions(self) -> List[Position]:\n        """Get all open positions"""\n        return list(self.positions.values())\n    \n    # ========================================================================\n    # CORRELATION CALCULATION\n    # ========================================================================\n    \n    def calculate_position_correlation(self, \n                                      pos1: Position, \n                                      pos2: Position) -> float:\n        """\n        Calculate correlation between two positions.\n        \n        Uses feature vectors to determine how similar positions are.\n        High correlation (>0.5) = positions likely move together.\n        \n        Returns:\n            Correlation coefficient [-1, 1]\n        """\n        # Get feature vectors\n        vec1 = pos1.get_correlation_vector()\n        vec2 = pos2.get_correlation_vector()\n        \n        # Normalize vectors\n        if np.linalg.norm(vec1) == 0 or np.linalg.norm(vec2) == 0:\n            return 0.0\n        \n        vec1_norm = vec1 / np.linalg.norm(vec1)\n        vec2_norm = vec2 / np.linalg.norm(vec2)\n        \n        # Calculate cosine similarity (= correlation for normalized vectors)\n        correlation = np.dot(vec1_norm, vec2_norm)\n        \n        return correlation\n    \n    def get_correlated_positions(self, \n                                new_position: Position,\n                                threshold: Optional[float] = None) -> List[Tuple[Position, float]]:\n        """\n        Find existing positions correlated with new position.\n        \n        Args:\n            new_position: Position to check\n            threshold: Correlation threshold (default: from config)\n        \n        Returns:\n            List of (position, correlation) tuples\n        """\n        threshold = threshold or self.config.correlation_threshold\n        \n        correlated = []\n        \n        for pos in self.positions.values():\n            corr = self.calculate_position_correlation(new_position, pos)\n            \n            if abs(corr) >= threshold:\n                correlated.append((pos, corr))\n        \n        # Sort by correlation strength\n        correlated.sort(key=lambda x: abs(x[1]), reverse=True)\n        \n        return correlated\n    \n    # ========================================================================\n    # CORRELATION-ADJUSTED SIZING\n    # ========================================================================\n    \n    def calculate_correlation_adjusted_size(self,\n                                           base_size: float,\n                                           new_position: Position) -> Tuple[float, Dict]:\n        """\n        Adjust position size based on correlation with existing positions.\n        \n        This prevents overexposure when multiple correlated signals fire.\n        \n        Args:\n            base_size: Original Kelly-calculated size\n            new_position: New position (with correlation features)\n        \n        Returns:\n            (adjusted_size, adjustment_details)\n        """\n        if not self.config.enable_correlation_adjustment:\n            return base_size, {'reason': 'disabled'}\n        \n        # Get correlated positions\n        correlated = self.get_correlated_positions(new_position)\n        \n        if not correlated:\n            return base_size, {'reason': 'no_correlation'}\n        \n        # Calculate correlated exposure\n        correlated_exposure = 0.0\n        correlation_details = []\n        \n        for pos, corr in correlated:\n            # Weight exposure by correlation strength\n            weighted_exposure = pos.size_usd * abs(corr)\n            correlated_exposure += weighted_exposure\n            \n            correlation_details.append({\n                'position_id': pos.id,\n                'strategy': pos.strategy,\n                'size': pos.size_usd,\n                'correlation': corr,\n                'weighted_exposure': weighted_exposure\n            })\n        \n        # Calculate adjustment factor\n        # The more correlated exposure, the smaller the new position\n        max_correlated_exposure = self.config.max_correlated_exposure * self.bankroll\n        \n        if correlated_exposure >= max_correlated_exposure:\n            # Already at max correlated exposure\n            adjusted_size = 0.0\n            reason = "max_correlated_exposure_reached"\n        else:\n            # Reduce size proportionally\n            remaining_capacity = max_correlated_exposure - correlated_exposure\n            adjustment_factor = remaining_capacity / max_correlated_exposure\n            \n            adjusted_size = base_size * adjustment_factor\n            reason = "correlation_adjusted"\n        \n        # Apply absolute limits\n        current_exposure = self.get_total_exposure()\n        max_total = self.config.max_total_exposure * self.bankroll\n        remaining_total = max_total - current_exposure\n        \n        adjusted_size = min(adjusted_size, remaining_total)\n        \n        # Round to 2 decimals\n        adjusted_size = round(adjusted_size, 2)\n        \n        # Log significant adjustments\n        reduction_pct = (1 - adjusted_size / base_size) * 100 if base_size > 0 else 0\n        \n        if reduction_pct > 20:\n            self.logger.warning(\n                f"‚ö†Ô∏è Position size reduced by {reduction_pct:.0f}% due to correlation\\n"\n                f"   Original: ${base_size:.2f}\\n"\n                f"   Adjusted: ${adjusted_size:.2f}\\n"\n                f"   Correlated exposure: ${correlated_exposure:.2f}\\n"\n                f"   Correlated positions: {len(correlated)}"\n            )\n        \n        adjustment_details = {\n            'reason': reason,\n            'original_size': base_size,\n            'adjusted_size': adjusted_size,\n            'reduction_pct': reduction_pct,\n            'correlated_exposure': correlated_exposure,\n            'correlated_positions': len(correlated),\n            'details': correlation_details\n        }\n        \n        return adjusted_size, adjustment_details\n    \n    # ========================================================================\n    # PORTFOLIO METRICS\n    # ========================================================================\n    \n    def get_total_exposure(self) -> float:\n        """Get total USD exposure across all positions"""\n        return sum(pos.size_usd for pos in self.positions.values())\n    \n    def get_exposure_pct(self) -> float:\n        """Get exposure as percentage of bankroll"""\n        return (self.get_total_exposure() / self.bankroll) * 100\n    \n    def get_concentration_by_asset(self) -> Dict[str, float]:\n        """Get exposure concentration by asset (token_id)"""\n        concentration = {}\n        total_exposure = self.get_total_exposure()\n        \n        for pos in self.positions.values():\n            token = pos.token_id\n            if token not in concentration:\n                concentration[token] = 0.0\n            concentration[token] += pos.size_usd\n        \n        # Convert to percentages\n        if total_exposure > 0:\n            concentration = {\n                k: (v / total_exposure) * 100 \n                for k, v in concentration.items()\n            }\n        \n        return concentration\n    \n    def get_concentration_by_strategy(self) -> Dict[str, float]:\n        """Get exposure concentration by strategy"""\n        concentration = {}\n        total_exposure = self.get_total_exposure()\n        \n        for pos in self.positions.values():\n            strategy = pos.strategy\n            if strategy not in concentration:\n                concentration[strategy] = 0.0\n            concentration[strategy] += pos.size_usd\n        \n        # Convert to percentages\n        if total_exposure > 0:\n            concentration = {\n                k: (v / total_exposure) * 100 \n                for k, v in concentration.items()\n            }\n        \n        return concentration\n    \n    def check_risk_limits(self) -> Dict[str, bool]:\n        """Check if portfolio is within risk limits"""\n        total_exposure = self.get_total_exposure()\n        max_total = self.config.max_total_exposure * self.bankroll\n        \n        # Check total exposure\n        within_total_limit = total_exposure <= max_total\n        \n        # Check concentration limits\n        asset_concentration = self.get_concentration_by_asset()\n        max_asset_conc = max(asset_concentration.values()) if asset_concentration else 0\n        within_concentration_limit = max_asset_conc <= self.config.max_concentration * 100\n        \n        # Check individual position limits\n        max_position_size = max(\n            (pos.size_usd for pos in self.positions.values()),\n            default=0\n        )\n        within_position_limit = max_position_size <= self.config.max_position_pct * self.bankroll\n        \n        return {\n            'within_total_limit': within_total_limit,\n            'within_concentration_limit': within_concentration_limit,\n            'within_position_limit': within_position_limit,\n            'all_limits_ok': all([\n                within_total_limit,\n                within_concentration_limit,\n                within_position_limit\n            ])\n        }\n    \n    def get_portfolio_metrics(self) -> Dict:\n        """Get comprehensive portfolio metrics"""\n        total_exposure = self.get_total_exposure()\n        \n        # Win rate\n        if self.closed_positions:\n            wins = sum(1 for p in self.closed_positions if p.pnl > 0)\n            win_rate = (wins / len(self.closed_positions)) * 100\n        else:\n            win_rate = 0.0\n        \n        # Average correlation\n        correlations = []\n        positions = list(self.positions.values())\n        for i in range(len(positions)):\n            for j in range(i + 1, len(positions)):\n                corr = self.calculate_position_correlation(positions[i], positions[j])\n                correlations.append(abs(corr))\n        avg_correlation = sum(correlations) / len(correlations) if correlations else 0.0\n        \n        return {\n            'bankroll': self.bankroll,\n            'total_pnl': self.total_pnl,\n            'roi_pct': (self.total_pnl / (self.bankroll - self.total_pnl)) * 100,\n            'open_positions': len(self.positions),\n            'closed_positions': len(self.closed_positions),\n            'total_exposure_usd': total_exposure,\n            'exposure_pct': (total_exposure / self.bankroll) * 100,\n            'win_rate': win_rate,\n            'avg_correlation': avg_correlation,\n            'asset_concentration': self.get_concentration_by_asset(),\n            'strategy_concentration': self.get_concentration_by_strategy(),\n            'risk_limits': self.check_risk_limits()\n        }\n    \n    def print_portfolio_summary(self):\n        """Print formatted portfolio summary"""\n        metrics = self.get_portfolio_metrics()\n        \n        print("\\n" + "="*80)\n        print("üíº PORTFOLIO SUMMARY")\n        print("="*80)\n        print(f"\\nüí∞ Bankroll: ${metrics['bankroll']:,.2f}")\n        print(f"üìà Total P&L: ${metrics['total_pnl']:+,.2f} ({metrics['roi_pct']:+.1f}%)")\n        print(f"\\nüìä Positions:")\n        print(f"   Open: {metrics['open_positions']}")\n        print(f"   Closed: {metrics['closed_positions']}")\n        print(f"   Win Rate: {metrics['win_rate']:.1f}%")\n        print(f"\\nüõ°Ô∏è Risk Metrics:")\n        print(f"   Total Exposure: ${metrics['total_exposure_usd']:,.2f} ({metrics['exposure_pct']:.1f}%)")\n        print(f"   Avg Correlation: {metrics['avg_correlation']:.2f}")\n        \n        if metrics['asset_concentration']:\n            print(f"\\nüéØ Asset Concentration:")\n            for asset, pct in sorted(metrics['asset_concentration'].items(), key=lambda x: x[1], reverse=True):\n                print(f"   {asset}: {pct:.1f}%")\n        \n        limits = metrics['risk_limits']\n        status = "‚úÖ" if limits['all_limits_ok'] else "‚ö†Ô∏è"\n        print(f"\\n{status} Risk Limits: {'WITHIN LIMITS' if limits['all_limits_ok'] else 'EXCEEDED'}")\n        print("="*80 + "\\n")\n\n\n# ============================================================================\n# EXAMPLE USAGE\n# ============================================================================\n\ndef main():\n    """Example portfolio management workflow"""\n    logging.basicConfig(\n        level=logging.INFO,\n        format='%(levelname)s - %(message)s'\n    )\n    \n    # Initialize portfolio\n    portfolio = PortfolioManager(bankroll=10000)\n    \n    # Create sample positions\n    pos1 = Position(\n        id="",\n        strategy="BTC Lag Predictive",\n        token_id="btc_100k",\n        direction="YES",\n        entry_price=0.65,\n        size_usd=1000,\n        stop_loss=0.62,\n        take_profit=0.72,\n        opened_at=datetime.now(),\n        correlation_features={\n            'btc_exposure': 1.0,\n            'sentiment': 0.5,\n            'volume_profile': 0.7,\n            'trend_direction': 1.0,\n            'volatility': 0.3\n        }\n    )\n    \n    pos2 = Position(\n        id="",\n        strategy="BTC Multi-Source Lag",\n        token_id="crypto_market",\n        direction="YES",\n        entry_price=0.58,\n        size_usd=1200,\n        stop_loss=0.55,\n        take_profit=0.65,\n        opened_at=datetime.now(),\n        correlation_features={\n            'btc_exposure': 0.9,   # Highly correlated with pos1\n            'sentiment': 0.6,\n            'volume_profile': 0.6,\n            'trend_direction': 1.0,\n            'volatility': 0.4\n        }\n    )\n    \n    # Add positions\n    id1 = portfolio.add_position(pos1)\n    id2 = portfolio.add_position(pos2)\n    \n    # Check correlation\n    print(f"\\nüîç Correlation between positions: {portfolio.calculate_position_correlation(pos1, pos2):.2f}")\n    \n    # Test correlation-adjusted sizing for new position\n    pos3 = Position(\n        id="",\n        strategy="Cross-Exchange Arb",\n        token_id="btc_100k",\n        direction="YES",\n        entry_price=0.66,\n        size_usd=1500,  # Base size from Kelly\n        stop_loss=0.64,\n        take_profit=0.70,\n        opened_at=datetime.now(),\n        correlation_features={\n            'btc_exposure': 0.95,  # Very correlated!\n            'sentiment': 0.5,\n            'volume_profile': 0.8,\n            'trend_direction': 1.0,\n            'volatility': 0.2\n        }\n    )\n    \n    base_size = 1500\n    adjusted_size, details = portfolio.calculate_correlation_adjusted_size(base_size, pos3)\n    \n    print(f"\\nüìä Position Sizing Adjustment:")\n    print(f"   Original (Kelly): ${base_size:.2f}")\n    print(f"   Adjusted: ${adjusted_size:.2f}")\n    print(f"   Reduction: {details['reduction_pct']:.1f}%")\n    print(f"   Reason: {details['reason']}")\n    \n    # Portfolio summary\n    portfolio.print_portfolio_summary()\n\n\nif __name__ == "__main__":\n    main()\n